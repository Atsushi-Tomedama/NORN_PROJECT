# ==============================================================================\n# PROGETTO NORN: NEURAL ONCOLOGY RISK NETWORK\n# Autore: Dany Marcel Toukam Megaptche\n# Tesi di Laurea in Medicina e Chirurgia - UniversitÃ  di Bologna\n# ==============================================================================\n\nimport numpy as np\nimport pandas as pd\nimport torch\nimport torch.nn as nn\nimport os\nimport sys\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder\nfrom sklearn.compose import ColumnTransformer\n\n# Imports bibliothÃ¨ques spÃ©cifiques\ntry:\n    import torchtuples as tt\n    from pycox.models import CoxPH\n    from pycox.evaluation import EvalSurv\nexcept ImportError:\n    print("âŒ Errore: Librerie mancanti. Esegui: pip install -r requirements.txt")\n    sys.exit(1)\n\n# Configurazione Hardware\ndevice = torch.device("cuda" if torch.cuda.is_available() else "cpu")\nprint(f"ðŸš€ NORN SYSTEM STARTUP | DEVICE: {device}")\n\n# ------------------------------------------------------------------------------\n# 1. GENERATORE DATI SINTETICI (Per Demo Pubblica)\n# ------------------------------------------------------------------------------\ndef generate_synthetic_data(n_samples=1000):\n    """Genera dati finti se il dataset reale MSK-CHORD non Ã¨ presente."""\n    print("\nâš ï¸  ATTENZIONE: Dataset MSK-CHORD non trovato.")\n    print("âš™ï¸  Avvio generazione dati SINTETICI per dimostrazione...")\n    \n    np.random.seed(42)\n    data = {\n        'TMB_NONSYNONYMOUS': np.random.lognormal(mean=2, sigma=1, size=n_samples),\n        'SAMPLE_TYPE': np.random.choice(['Primary', 'Metastasis'], n_samples),\n        'GENDER': np.random.choice(['Male', 'Female'], n_samples),\n        'CANCER_TYPE': np.random.choice(['Lung', 'Melanoma', 'Breast', 'Colorectal', 'Other'], n_samples),\n        'OS_MONTHS': np.random.exponential(scale=24, size=n_samples), # Sopravvivenza simulata\n        'Event': np.random.choice([0, 1], n_samples, p=[0.3, 0.7]) # 0=Vivo, 1=Deceduto\n    }\n    \n    df = pd.DataFrame(data)\n    # Creiamo OS_STATUS solo per compatibilitÃ  col formato originale\n    df['OS_STATUS'] = df['Event'].apply(lambda x: '1:DECEASED' if x==1 else '0:LIVING')\n    \n    print(f"âœ… Dati sintetici generati: {n_samples} pazienti simulati.\n")\n    return df\n\n# ------------------------------------------------------------------------------\n# 2. DATA LOADING\n# ------------------------------------------------------------------------------\ndef load_data(patient_file, sample_file):\n    # Se i file non esistono, usa il generatore sintetico\n    if not os.path.exists(patient_file) or not os.path.exists(sample_file):\n        return generate_synthetic_data()\n\n    print("ðŸ“¥ Caricamento Dataset Reale MSK-CHORD...")\n    df_pat = pd.read_csv(patient_file, sep='\t', comment='#', low_memory=False)\n    df_sam = pd.read_csv(sample_file, sep='\t', comment='#', low_memory=False)\n    df = pd.merge(df_pat, df_sam, on='PATIENT_ID')\n    \n    # Preprocessing\n    features = ['TMB_NONSYNONYMOUS', 'SAMPLE_TYPE', 'GENDER', 'CANCER_TYPE']\n    df_clean = df.dropna(subset=features + ['OS_MONTHS', 'OS_STATUS']).copy()\n    \n    # Target Transformation\n    df_clean['Event'] = df_clean['OS_STATUS'].str.contains("DECEASED|1").astype(int)\n    \n    # Group rare cancers\n    top_cancers = df_clean['CANCER_TYPE'].value_counts().nlargest(15).index\n    df_clean.loc[~df_clean['CANCER_TYPE'].isin(top_cancers), 'CANCER_TYPE'] = 'Other'\n    \n    return df_clean\n\n# ------------------------------------------------------------------------------\n# 3. NORN MODEL ARCHITECTURE\n# ------------------------------------------------------------------------------\nclass NORN_Net(nn.Module):\n    def __init__(self, in_features):\n        super(NORN_Net, self).__init__()\n        self.net = nn.Sequential(\n            nn.Linear(in_features, 64), nn.SELU(), nn.BatchNorm1d(64), nn.Dropout(0.3),\n            nn.Linear(64, 32), nn.SELU(), nn.BatchNorm1d(32), nn.Dropout(0.3),\n            nn.Linear(32, 16), nn.SELU(),\n            nn.Linear(16, 1)\n        )\n\n    def forward(self, input):\n        return self.net(input)\n\n# ------------------------------------------------------------------------------\n# MAIN EXECUTION\n# ------------------------------------------------------------------------------\nif __name__ == "__main__":\n    # Nomi file attesi\n    PATIENT_FILE = 'data_clinical_patient.txt'\n    SAMPLE_FILE = 'data_clinical_sample.txt'\n\n    # Caricamento (o generazione)\n    df = load_data(PATIENT_FILE, SAMPLE_FILE)\n    \n    # Feature Engineering\n    print("ðŸ›   Preprocessing e Feature Engineering...")\n    ct = ColumnTransformer([\n        ('num', StandardScaler(), ['TMB_NONSYNONYMOUS']),\n        ('cat', OneHotEncoder(sparse_output=False, handle_unknown='ignore'), ['SAMPLE_TYPE', 'GENDER', 'CANCER_TYPE'])\n    ])\n    \n    X_cols = ['TMB_NONSYNONYMOUS', 'SAMPLE_TYPE', 'GENDER', 'CANCER_TYPE']\n    \n    # Assicuriamo che le colonne esistano (in caso di dati sintetici)\n    df = df[df['OS_MONTHS'] > 0] # Rimuove tempi negativi o zero\n    \n    get_target = lambda df: (df['OS_MONTHS'].values.astype('float32'), df['Event'].values.astype('float32'))\n    \n    df_train, df_test = train_test_split(df, test_size=0.3, random_state=42)\n    X_train = ct.fit_transform(df_train[X_cols]).astype('float32')\n    y_train = get_target(df_train)\n    \n    # Model Init\n    input_nodes = X_train.shape[1]\n    net = NORN_Net(input_nodes).to(device)\n    model = CoxPH(net, tt.optim.Adam(lr=0.001))\n    \n    # Training\n    print(f"ðŸ§  Avvio Training NORN su {len(df_train)} pazienti...")\n    model.fit(X_train, y_train, batch_size=256, epochs=50, verbose=True)\n    \n    print("\nâœ… SUCCESS: Modello addestrato e pronto.")\n    print("   (Nota: Se hai usato dati sintetici, le curve di sopravvivenza sono simulate)")